import{e,w as t,n,c as s,g as o,f as r,i,j as a,h as l,B as c,k as u,l as p,F as d,S as f,u as m,m as h,p as v,s as g,r as _,q as b,t as y,v as C}from"./@vue_runtime-core@3.2.47-1437c93d.js";import{q as S,w,I as E,e as A,E as T,a as P,H as k,b as x,K as N,x as $,L,c as R,M as O,O as j,l as V,z as M,v as F,D as B,k as U,P as D,Q as I}from"./@vue_shared@3.2.47-699fd3ac.js";import{t as H}from"./@vue_reactivity@3.2.47-71c1ef0d.js";const q="undefined"!=typeof document?document:null,z=q&&q.createElement("template"),K={insert:(e,t,n)=>{t.insertBefore(e,n||null)},remove:e=>{const t=e.parentNode;t&&t.removeChild(e)},createElement:(e,t,n,s)=>{const o=t?q.createElementNS("http://www.w3.org/2000/svg",e):q.createElement(e,n?{is:n}:void 0);return"select"===e&&s&&null!=s.multiple&&o.setAttribute("multiple",s.multiple),o},createText:e=>q.createTextNode(e),createComment:e=>q.createComment(e),setText:(e,t)=>{e.nodeValue=t},setElementText:(e,t)=>{e.textContent=t},parentNode:e=>e.parentNode,nextSibling:e=>e.nextSibling,querySelector:e=>q.querySelector(e),setScopeId(e,t){e.setAttribute(t,"")},
// __UNSAFE__
// Reason: innerHTML.
// Static content here can only come from compiled templates.
// As long as the user only uses trusted templates, this is safe.
insertStaticContent(e,t,n,s,o,r){const i=n?n.previousSibling:t.lastChild;if(o&&(o===r||o.nextSibling))for(;t.insertBefore(o.cloneNode(!0),n),o!==r&&(o=o.nextSibling););else{z.innerHTML=s?`<svg>${e}</svg>`:e;const o=z.content;if(s){const e=o.firstChild;for(;e.firstChild;)o.appendChild(e.firstChild);o.removeChild(e)}t.insertBefore(o,n)}return[
// first
i?i.nextSibling:t.firstChild,
// last
n?n.previousSibling:t.lastChild]}};const G=/[^\\];\s*$/,W=/\s*!important$/;function X(e,n,s){if(x(s))s.forEach((t=>X(e,n,t)));else if(null==s&&(s=""),G.test(s)&&t(`Unexpected semicolon at the end of '${n}' style value: '${s}'`),n.startsWith("--"))e.setProperty(n,s);else{const t=function(e,t){const n=J[t];if(n)return n;let s=S(t);if("filter"!==s&&s in e)return J[t]=s;s=U(s);for(let o=0;o<Q.length;o++){const n=Q[o]+s;if(n in e)return J[t]=n}return t}(e,n);W.test(s)?e.setProperty(E(t),s.replace(W,""),"important"):e[t]=s}}const Q=["Webkit","Moz","ms"],J={};const Y="http://www.w3.org/1999/xlink";function Z(e,t,n,s){e.addEventListener(t,n,s)}function ee(e,t,n,s,o=null){const r=e._vei||(e._vei={}),i=r[t];if(s&&i)i.value=s;else{const[n,a]=function(e){let t;if(te.test(e)){let n;for(t={};n=e.match(te);)e=e.slice(0,e.length-n[0].length),t[n[0].toLowerCase()]=!0}const n=":"===e[2]?e.slice(3):E(e.slice(2));return[n,t]}(t);if(s){const i=r[t]=function(e,t){const n=e=>{if(e._vts){if(e._vts<=n.attached)return}else e._vts=Date.now();C(function(e,t){if(x(t)){const n=e.stopImmediatePropagation;return e.stopImmediatePropagation=()=>{n.call(e),e._stopped=!0},t.map((e=>t=>!t._stopped&&e&&e(t)))}return t}(e,n.value),t,5,[e])};return n.value=e,n.attached=oe(),n}(s,o);Z(e,n,i,a)}else i&&(!function(e,t,n,s){e.removeEventListener(t,n,s)}(e,n,i,a),r[t]=void 0)}}const te=/(?:Once|Passive|Capture)$/;let ne=0;const se=Promise.resolve(),oe=()=>ne||(se.then((()=>ne=0)),ne=Date.now());const re=/^on[a-z]/;function ie(t,n){const s=e(t);class o extends ce{constructor(e){super(s,e,n)}}return o.def=s,o}const ae=e=>ie(e,dt),le="undefined"!=typeof HTMLElement?HTMLElement:class{};class ce extends le{constructor(e,n={},s){super(),this._def=e,this._props=n,this._instance=null,this._connected=!1,this._resolved=!1,this._numberProps=null,this.shadowRoot&&s?s(this._createVNode(),this.shadowRoot):(this.shadowRoot&&t("Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use `defineSSRCustomElement`."),this.attachShadow({mode:"open"}),this._def.__asyncLoader||this._resolveProps(this._def))}connectedCallback(){this._connected=!0,this._instance||(this._resolved?this._update():this._resolveDef())}disconnectedCallback(){this._connected=!1,n((()=>{this._connected||(pt(null,this.shadowRoot),this._instance=null)}))}
/**
   * resolve inner component definition (handle possible async component)
   */_resolveDef(){this._resolved=!0;for(let n=0;n<this.attributes.length;n++)this._setAttr(this.attributes[n].name);new MutationObserver((e=>{for(const t of e)this._setAttr(t.attributeName)})).observe(this,{attributes:!0});const e=(e,t=!1)=>{const{props:n,styles:s}=e;let o;if(n&&!x(n))for(const r in n){const e=n[r];(e===Number||e&&e.type===Number)&&(r in this._props&&(this._props[r]=w(this._props[r])),(o||(o=Object.create(null)))[S(r)]=!0)}this._numberProps=o,t&&this._resolveProps(e),this._applyStyles(s),this._update()},t=this._def.__asyncLoader;t?t().then((t=>e(t,!0))):e(this._def)}_resolveProps(e){const{props:t}=e,n=x(t)?t:Object.keys(t||{});for(const s of Object.keys(this))"_"!==s[0]&&n.includes(s)&&this._setProp(s,this[s],!0,!1);for(const s of n.map(S))Object.defineProperty(this,s,{get(){return this._getProp(s)},set(e){this._setProp(s,e)}})}_setAttr(e){let t=this.getAttribute(e);const n=S(e);this._numberProps&&this._numberProps[n]&&(t=w(t)),this._setProp(n,t,!1)}
/**
   * @internal
   */_getProp(e){return this._props[e]}
/**
   * @internal
   */_setProp(e,t,n=!0,s=!0){t!==this._props[e]&&(this._props[e]=t,s&&this._instance&&this._update(),n&&(!0===t?this.setAttribute(E(e),""):"string"==typeof t||"number"==typeof t?this.setAttribute(E(e),t+""):t||this.removeAttribute(E(e))))}_update(){pt(this._createVNode(),this.shadowRoot)}_createVNode(){const e=s(this._def,A({},this._props));return this._instance||(e.ce=e=>{this._instance=e,e.isCE=!0,e.ceReload=e=>{this._styles&&(this._styles.forEach((e=>this.shadowRoot.removeChild(e))),this._styles.length=0),this._applyStyles(e),this._instance=null,this._update()};const t=(e,t)=>{this.dispatchEvent(new CustomEvent(e,{detail:t}))};e.emit=(e,...n)=>{t(e,n),E(e)!==e&&t(E(e),n)};let n=this;for(;n=n&&(n.parentNode||n.host);)if(n instanceof ce){e.parent=n._instance,e.provides=n._instance.provides;break}}),e}_applyStyles(e){e&&e.forEach((e=>{const t=document.createElement("style");t.textContent=e,this.shadowRoot.appendChild(t),(this._styles||(this._styles=[])).push(t)}))}}function ue(e="$style"){{const n=o();if(!n)return t("useCssModule must be called inside setup()"),T;const s=n.type.__cssModules;if(!s)return t("Current instance does not have CSS modules injected."),T;const r=s[e];return r||(t(`Current instance does not have CSS module named "${e}".`),T)}}function pe(e){const n=o();if(!n)return void t("useCssVars is called without current active component instance.");const s=n.ut=(t=e(n.proxy))=>{Array.from(document.querySelectorAll(`[data-v-owner="${n.uid}"]`)).forEach((e=>fe(e,t)))},l=()=>{const t=e(n.proxy);de(n.subTree,t),s(t)};r(l),i((()=>{const e=new MutationObserver(l);e.observe(n.subTree.el.parentNode,{childList:!0}),a((()=>e.disconnect()))}))}function de(e,t){if(128&e.shapeFlag){const n=e.suspense;e=n.activeBranch,n.pendingBranch&&!n.isHydrating&&n.effects.push((()=>{de(n.activeBranch,t)}))}for(;e.component;)e=e.component.subTree;if(1&e.shapeFlag&&e.el)fe(e.el,t);else if(e.type===d)e.children.forEach((e=>de(e,t)));else if(e.type===f){let{el:n,anchor:s}=e;for(;n&&(fe(n,t),n!==s);)n=n.nextSibling}}function fe(e,t){if(1===e.nodeType){const n=e.style;for(const e in t)n.setProperty(`--${e}`,t[e])}}const me="transition",he="animation",ve=(e,{slots:t})=>l(c,Ce(e),t);ve.displayName="Transition";const ge={name:String,type:String,css:{type:Boolean,default:!0},duration:[String,Number,Object],enterFromClass:String,enterActiveClass:String,enterToClass:String,appearFromClass:String,appearActiveClass:String,appearToClass:String,leaveFromClass:String,leaveActiveClass:String,leaveToClass:String},_e=ve.props=A({},c.props,ge),be=(e,t=[])=>{x(e)?e.forEach((e=>e(...t))):e&&e(...t)},ye=e=>!!e&&(x(e)?e.some((e=>e.length>1)):e.length>1);function Ce(e){const t={};for(const A in e)A in ge||(t[A]=e[A]);if(!1===e.css)return t;const{name:n="v",type:s,duration:o,enterFromClass:r=`${n}-enter-from`,enterActiveClass:i=`${n}-enter-active`,enterToClass:a=`${n}-enter-to`,appearFromClass:l=r,appearActiveClass:c=i,appearToClass:u=a,leaveFromClass:p=`${n}-leave-from`,leaveActiveClass:d=`${n}-leave-active`,leaveToClass:f=`${n}-leave-to`}=e,m=function(e){if(null==e)return null;if(P(e))return[Se(e.enter),Se(e.leave)];{const t=Se(e);return[t,t]}}(o),h=m&&m[0],v=m&&m[1],{onBeforeEnter:g,onEnter:_,onEnterCancelled:b,onLeave:y,onLeaveCancelled:C,onBeforeAppear:S=g,onAppear:w=_,onAppearCancelled:E=b}=t,T=(e,t,n)=>{Ee(e,t?u:a),Ee(e,t?c:i),n&&n()},k=(e,t)=>{e._isLeaving=!1,Ee(e,p),Ee(e,f),Ee(e,d),t&&t()},x=e=>(t,n)=>{const o=e?w:_,i=()=>T(t,e,n);be(o,[t,i]),Ae((()=>{Ee(t,e?l:r),we(t,e?u:a),ye(o)||Pe(t,s,h,i)}))};return A(t,{onBeforeEnter(e){be(g,[e]),we(e,r),we(e,i)},onBeforeAppear(e){be(S,[e]),we(e,l),we(e,c)},onEnter:x(!1),onAppear:x(!0),onLeave(e,t){e._isLeaving=!0;const n=()=>k(e,t);we(e,p),$e(),we(e,d),Ae((()=>{e._isLeaving&&(Ee(e,p),we(e,f),ye(y)||Pe(e,s,v,n))})),be(y,[e,n])},onEnterCancelled(e){T(e,!1),be(b,[e])},onAppearCancelled(e){T(e,!0),be(E,[e])},onLeaveCancelled(e){k(e),be(C,[e])}})}function Se(e){const t=w(e);return u(t,"<transition> explicit duration"),t}function we(e,t){t.split(/\s+/).forEach((t=>t&&e.classList.add(t))),(e._vtc||(e._vtc=new Set)).add(t)}function Ee(e,t){t.split(/\s+/).forEach((t=>t&&e.classList.remove(t)));const{_vtc:n}=e;n&&(n.delete(t),n.size||(e._vtc=void 0))}function Ae(e){requestAnimationFrame((()=>{requestAnimationFrame(e)}))}let Te=0;function Pe(e,t,n,s){const o=e._endId=++Te,r=()=>{o===e._endId&&s()};if(n)return setTimeout(r,n);const{type:i,timeout:a,propCount:l}=ke(e,t);if(!i)return s();const c=i+"end";let u=0;const p=()=>{e.removeEventListener(c,d),r()},d=t=>{t.target===e&&++u>=l&&p()};setTimeout((()=>{u<l&&p()}),a+1),e.addEventListener(c,d)}function ke(e,t){const n=window.getComputedStyle(e),s=e=>(n[e]||"").split(", "),o=s(`${me}Delay`),r=s(`${me}Duration`),i=xe(o,r),a=s(`${he}Delay`),l=s(`${he}Duration`),c=xe(a,l);let u=null,p=0,d=0;t===me?i>0&&(u=me,p=i,d=r.length):t===he?c>0&&(u=he,p=c,d=l.length):(p=Math.max(i,c),u=p>0?i>c?me:he:null,d=u?u===me?r.length:l.length:0);return{type:u,timeout:p,propCount:d,hasTransform:u===me&&/\b(transform|all)(,|$)/.test(s(`${me}Property`).toString())}}function xe(e,t){for(;e.length<t.length;)e=e.concat(e);return Math.max(...t.map(((t,n)=>Ne(t)+Ne(e[n]))))}function Ne(e){return 1e3*Number(e.slice(0,-1).replace(",","."))}function $e(){return document.body.offsetHeight}const Le=new WeakMap,Re=new WeakMap,Oe={name:"TransitionGroup",props:A({},_e,{tag:String,moveClass:String}),setup(e,{slots:n}){const r=o(),i=m();let a,l;return h((()=>{if(!a.length)return;const t=e.moveClass||`${e.name||"v"}-move`;if(!function(e,t,n){const s=e.cloneNode();e._vtc&&e._vtc.forEach((e=>{e.split(/\s+/).forEach((e=>e&&s.classList.remove(e)))}));n.split(/\s+/).forEach((e=>e&&s.classList.add(e))),s.style.display="none";const o=1===t.nodeType?t:t.parentNode;o.appendChild(s);const{hasTransform:r}=ke(s);return o.removeChild(s),r}(a[0].el,r.vnode.el,t))return;a.forEach(Ve),a.forEach(Me);const n=a.filter(Fe);$e(),n.forEach((e=>{const n=e.el,s=n.style;we(n,t),s.transform=s.webkitTransform=s.transitionDuration="";const o=n._moveCb=e=>{e&&e.target!==n||e&&!/transform$/.test(e.propertyName)||(n.removeEventListener("transitionend",o),n._moveCb=null,Ee(n,t))};n.addEventListener("transitionend",o)}))})),()=>{const o=H(e),c=Ce(o);let u=o.tag||d;a=l,l=n.default?v(n.default()):[];for(let e=0;e<l.length;e++){const n=l[e];null!=n.key?g(n,_(n,c,i,r)):t("<TransitionGroup> children must be keyed.")}if(a)for(let e=0;e<a.length;e++){const t=a[e];g(t,_(t,c,i,r)),Le.set(t,t.el.getBoundingClientRect())}return s(u,null,l)}}},je=Oe;function Ve(e){const t=e.el;t._moveCb&&t._moveCb(),t._enterCb&&t._enterCb()}function Me(e){Re.set(e,e.el.getBoundingClientRect())}function Fe(e){const t=Le.get(e),n=Re.get(e),s=t.left-n.left,o=t.top-n.top;if(s||o){const t=e.el.style;return t.transform=t.webkitTransform=`translate(${s}px,${o}px)`,t.transitionDuration="0s",e}}const Be=e=>{const t=e.props["onUpdate:modelValue"]||!1;return x(t)?e=>M(t,e):t};function Ue(e){e.target.composing=!0}function De(e){const t=e.target;t.composing&&(t.composing=!1,t.dispatchEvent(new Event("input")))}const Ie={created(e,{modifiers:{lazy:t,trim:n,number:s}},o){e._assign=Be(o);const r=s||o.props&&"number"===o.props.type;Z(e,t?"change":"input",(t=>{if(t.target.composing)return;let s=e.value;n&&(s=s.trim()),r&&(s=k(s)),e._assign(s)})),n&&Z(e,"change",(()=>{e.value=e.value.trim()})),t||(Z(e,"compositionstart",Ue),Z(e,"compositionend",De),Z(e,"change",De))},
// set value on mounted so it's after min/max for type="range"
mounted(e,{value:t}){e.value=null==t?"":t},beforeUpdate(e,{value:t,modifiers:{lazy:n,trim:s,number:o}},r){if(e._assign=Be(r),e.composing)return;if(document.activeElement===e&&"range"!==e.type){if(n)return;if(s&&e.value.trim()===t)return;if((o||"number"===e.type)&&k(e.value)===t)return}const i=null==t?"":t;e.value!==i&&(e.value=i)}},He={
// #4096 array checkboxes need to be deep traversed
deep:!0,created(e,t,n){e._assign=Be(n),Z(e,"change",(()=>{const t=e._modelValue,n=We(e),s=e.checked,o=e._assign;if(x(t)){const e=N(t,n),r=-1!==e;if(s&&!r)o(t.concat(n));else if(!s&&r){const n=[...t];n.splice(e,1),o(n)}}else if($(t)){const e=new Set(t);s?e.add(n):e.delete(n),o(e)}else o(Xe(e,s))}))},
// set initial checked on mount to wait for true-value/false-value
mounted:qe,beforeUpdate(e,t,n){e._assign=Be(n),qe(e,t,n)}};function qe(e,{value:t,oldValue:n},s){e._modelValue=t,x(t)?e.checked=N(t,s.props.value)>-1:$(t)?e.checked=t.has(s.props.value):t!==n&&(e.checked=L(t,Xe(e,!0)))}const ze={created(e,{value:t},n){e.checked=L(t,n.props.value),e._assign=Be(n),Z(e,"change",(()=>{e._assign(We(e))}))},beforeUpdate(e,{value:t,oldValue:n},s){e._assign=Be(s),t!==n&&(e.checked=L(t,s.props.value))}},Ke={
// <select multiple> value need to be deep traversed
deep:!0,created(e,{value:t,modifiers:{number:n}},s){const o=$(t);Z(e,"change",(()=>{const t=Array.prototype.filter.call(e.options,(e=>e.selected)).map((e=>n?k(We(e)):We(e)));e._assign(e.multiple?o?new Set(t):t:t[0])})),e._assign=Be(s)},
// set value in mounted & updated because <select> relies on its children
// <option>s.
mounted(e,{value:t}){Ge(e,t)},beforeUpdate(e,t,n){e._assign=Be(n)},updated(e,{value:t}){Ge(e,t)}};function Ge(e,n){const s=e.multiple;if(!s||x(n)||$(n)){for(let t=0,o=e.options.length;t<o;t++){const o=e.options[t],r=We(o);if(s)x(n)?o.selected=N(n,r)>-1:o.selected=n.has(r);else if(L(We(o),n))return void(e.selectedIndex!==t&&(e.selectedIndex=t))}s||-1===e.selectedIndex||(e.selectedIndex=-1)}else t(`<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(n).slice(8,-1)}.`)}function We(e){return"_value"in e?e._value:e.value}function Xe(e,t){const n=t?"_trueValue":"_falseValue";return n in e?e[n]:t}const Qe={created(e,t,n){Ye(e,t,n,null,"created")},mounted(e,t,n){Ye(e,t,n,null,"mounted")},beforeUpdate(e,t,n,s){Ye(e,t,n,s,"beforeUpdate")},updated(e,t,n,s){Ye(e,t,n,s,"updated")}};function Je(e,t){switch(e){case"SELECT":return Ke;case"TEXTAREA":return Ie;default:switch(t){case"checkbox":return He;case"radio":return ze;default:return Ie}}}function Ye(e,t,n,s,o){const r=Je(e.tagName,n.props&&n.props.type)[o];r&&r(e,t,n,s)}const Ze=["ctrl","shift","alt","meta"],et={stop:e=>e.stopPropagation(),prevent:e=>e.preventDefault(),self:e=>e.target!==e.currentTarget,ctrl:e=>!e.ctrlKey,shift:e=>!e.shiftKey,alt:e=>!e.altKey,meta:e=>!e.metaKey,left:e=>"button"in e&&0!==e.button,middle:e=>"button"in e&&1!==e.button,right:e=>"button"in e&&2!==e.button,exact:(e,t)=>Ze.some((n=>e[`${n}Key`]&&!t.includes(n)))},tt=(e,t)=>(n,...s)=>{for(let e=0;e<t.length;e++){const s=et[t[e]];if(s&&s(n,t))return}return e(n,...s)},nt={esc:"escape",space:" ",up:"arrow-up",left:"arrow-left",right:"arrow-right",down:"arrow-down",delete:"backspace"},st=(e,t)=>n=>{if(!("key"in n))return;const s=E(n.key);return t.some((e=>e===s||nt[e]===s))?e(n):void 0},ot={beforeMount(e,{value:t},{transition:n}){e._vod="none"===e.style.display?"":e.style.display,n&&t?n.beforeEnter(e):rt(e,t)},mounted(e,{value:t},{transition:n}){n&&t&&n.enter(e)},updated(e,{value:t,oldValue:n},{transition:s}){!t!=!n&&(s?t?(s.beforeEnter(e),rt(e,!0),s.enter(e)):s.leave(e,(()=>{rt(e,!1)})):rt(e,t))},beforeUnmount(e,{value:t}){rt(e,t)}};function rt(e,t){e.style.display=t?e._vod:"none"}const it=A({patchProp:(e,n,s,o,r=!1,i,a,l,c)=>{"class"===n?function(e,t,n){const s=e._vtc;s&&(t=(t?[t,...s]:[...s]).join(" ")),null==t?e.removeAttribute("class"):n?e.setAttribute("class",t):e.className=t}(e,o,r):"style"===n?function(e,t,n){const s=e.style,o=V(n);if(n&&!o){if(t&&!V(t))for(const e in t)null==n[e]&&X(s,e,"");for(const e in n)X(s,e,n[e])}else{const r=s.display;o?t!==n&&(s.cssText=n):t&&e.removeAttribute("style"),"_vod"in e&&(s.display=r)}}(e,s,o):F(n)?B(n)||ee(e,n,0,o,a):("."===n[0]?(n=n.slice(1),1):"^"===n[0]?(n=n.slice(1),0):function(e,t,n,s){if(s)return"innerHTML"===t||"textContent"===t||!!(t in e&&re.test(t)&&R(n));if("spellcheck"===t||"draggable"===t||"translate"===t)return!1;if("form"===t)return!1;if("list"===t&&"INPUT"===e.tagName)return!1;if("type"===t&&"TEXTAREA"===e.tagName)return!1;if(re.test(t)&&V(n))return!1;return t in e}(e,n,o,r))?function(e,n,s,o,r,i,a){if("innerHTML"===n||"textContent"===n)return o&&a(o,r,i),void(e[n]=null==s?"":s);if("value"===n&&"PROGRESS"!==e.tagName&&// custom elements may use _value internally
!e.tagName.includes("-")){e._value=s;const t=null==s?"":s;return e.value===t&&// #4956: always set for OPTION elements because its value falls back to
// textContent if no value attribute is present. And setting .value for
// OPTION has no side effect
"OPTION"!==e.tagName||(e.value=t),void(null==s&&e.removeAttribute(n))}let l=!1;if(""===s||null==s){const t=typeof e[n];"boolean"===t?s=I(s):null==s&&"string"===t?(s="",l=!0):"number"===t&&(s=0,l=!0)}try{e[n]=s}catch(c){l||t(`Failed setting prop "${n}" on <${e.tagName.toLowerCase()}>: value ${s} is invalid.`,c)}l&&e.removeAttribute(n)}(e,n,o,i,a,l,c):("true-value"===n?e._trueValue=o:"false-value"===n&&(e._falseValue=o),function(e,t,n,s,o){if(s&&t.startsWith("xlink:"))null==n?e.removeAttributeNS(Y,t.slice(6,t.length)):e.setAttributeNS(Y,t,n);else{const s=D(t);null==n||s&&!I(n)?e.removeAttribute(t):e.setAttribute(t,s?"":n)}}(e,n,o,r))}},K);let at,lt=!1;function ct(){return at||(at=b(it))}function ut(){return at=lt?at:y(it),lt=!0,at}const pt=(...e)=>{ct().render(...e)},dt=(...e)=>{ut().hydrate(...e)},ft=(...e)=>{const t=ct().createApp(...e);ht(t),vt(t);const{mount:n}=t;return t.mount=e=>{const s=gt(e);if(!s)return;const o=t._component;R(o)||o.render||o.template||(o.template=s.innerHTML),s.innerHTML="";const r=n(s,!1,s instanceof SVGElement);return s instanceof Element&&(s.removeAttribute("v-cloak"),s.setAttribute("data-v-app","")),r},t},mt=(...e)=>{const t=ut().createApp(...e);ht(t),vt(t);const{mount:n}=t;return t.mount=e=>{const t=gt(e);if(t)return n(t,!0,t instanceof SVGElement)},t};function ht(e){Object.defineProperty(e.config,"isNativeTag",{value:e=>O(e)||j(e),writable:!1})}function vt(e){if(p()){const n=e.config.isCustomElement;Object.defineProperty(e.config,"isCustomElement",{get:()=>n,set(){t("The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead.")}});const s=e.config.compilerOptions,o='The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom';Object.defineProperty(e.config,"compilerOptions",{get:()=>(t(o),s),set(){t(o)}})}}function gt(e){if(V(e)){const n=document.querySelector(e);return n||t(`Failed to mount app: mount target selector "${e}" returned null.`),n}return window.ShadowRoot&&e instanceof window.ShadowRoot&&"closed"===e.mode&&t('mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs'),e}let _t=!1;const bt=()=>{_t||(_t=!0,Ie.getSSRProps=({value:e})=>({value:e}),ze.getSSRProps=({value:e},t)=>{if(t.props&&L(t.props.value,e))return{checked:!0}},He.getSSRProps=({value:e},t)=>{if(x(e)){if(t.props&&N(e,t.props.value)>-1)return{checked:!0}}else if($(e)){if(t.props&&e.has(t.props.value))return{checked:!0}}else if(e)return{checked:!0}},Qe.getSSRProps=(e,t)=>{if("string"!=typeof t.type)return;const n=Je(
// resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
t.type.toUpperCase(),t.props&&t.props.type);return n.getSSRProps?n.getSSRProps(e,t):void 0},ot.getSSRProps=({value:e})=>{if(!e)return{style:{display:"none"}}})};export{ve as T,ce as V,je as a,st as b,He as c,ze as d,Ie as e,ft as f,mt as g,ie as h,ae as i,dt as j,bt as k,pe as l,Qe as m,Ke as n,pt as r,ue as u,ot as v,tt as w};
